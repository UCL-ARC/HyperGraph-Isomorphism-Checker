/*
 * CUDA_Kernels.cuh
 *
 *  Created on: Nov 4, 2025
 *      Author: blaze
 */

#ifndef GPU_SOLVER_CUDA_KERNELS_CUH_
#define GPU_SOLVER_CUDA_KERNELS_CUH_
#include <thrust/tuple.h>

const __device__ NodeKeyTuple MAX_TUPLE = thrust::make_tuple(UINT_MAX, 0, 0, 0);
#define FNV_OFFSET_BASIS 0xcbf29ce484222325ULL
#define FNV_PRIME 0x100000001b3ULL


/*-----------------------------------------------------------------------------------------------*/
/* Test Kernel */
/*-----------------------------------------------------------------------------------------------*/
__global__ void printItem(uint *CSR, uint *Start, uint *Num, uint *indexLabel, uint MaxArraySize, uint numPrint)
{
	uint tid = blockIdx.x*blockDim.x  + threadIdx.x; /* Gives the ThreadIndex */

	/* Check we are in memory range */
	if(tid<MaxArraySize)
    {
		printf("Item %d LabelInd %d,  StartNum %d %d \n", tid,indexLabel[tid], Start[tid] , Num[tid] );

		uint start =  Start[tid];

		for(int i=start;i<start+Num[tid];i++)
		{
			printf(" %d ", CSR[i] );
		}
		printf("\n");
    }

}
/*-----------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------*/
/* Debug prints the edge hashes that do not match */
/*-----------------------------------------------------------------------------------------------*/
__global__ void PrintEdgeMisMatch(  int numEdges, const uint* d_edge_LabelA, const uint* d_edge_LabelB,

											uint64_t* d_edge_neighborHashesA, uint64_t* d_edge_neighborHashesB    )
{
    // One thread per edge
    int edge_id = blockIdx.x * blockDim.x + threadIdx.x;

    if (edge_id < numEdges)
    {
    	if( d_edge_neighborHashesA[edge_id]!= d_edge_neighborHashesB[edge_id] )
    	{
    		printf(" %d  LabelIndA %d HashA 0x%llx  LabelIndB %d HashB 0x%llx \n", edge_id, d_edge_LabelA[edge_id] ,d_edge_neighborHashesA[edge_id], d_edge_LabelB[edge_id], d_edge_neighborHashesB[edge_id] );
    	}
    }
}
/*-----------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------*/
/* Computes a 64bit hash */
/*-----------------------------------------------------------------------------------------------*/
__device__ uint64_t fnv1a_hash_64(const void* data, size_t num_bytes)
{
    uint64_t hash = FNV_OFFSET_BASIS;
    const unsigned char* bytes = (const unsigned char*)data;

    for (size_t i = 0; i < num_bytes; ++i)
    {
        hash = hash ^ bytes[i];
        hash = hash * FNV_PRIME;
    }

    return hash;
}
/*-----------------------------------------------------------------------------------------------*/


/*-----------------------------------------------------------------------------------------------*/
/* Fixed Network ordering for Max 8 elements */
/*-----------------------------------------------------------------------------------------------*/
template <typename T>
__device__ __forceinline__ void compareAndSwap(T& a, T& b)
{
    if (b < a)
    {
        T temp = a;
        a = b;
        b = temp;
    }
}
template <typename T>
__device__ void sorting_network_8(T data[8])
{
    // Stage 1 (Odd)
    compareAndSwap(data[1], data[2]);
    compareAndSwap(data[3], data[4]);
    compareAndSwap(data[5], data[6]);
    // Stage 2 (Even)
    compareAndSwap(data[0], data[1]);
    compareAndSwap(data[2], data[3]);
    compareAndSwap(data[4], data[5]);
    compareAndSwap(data[6], data[7]);
    // Stage 3 (Odd)
    compareAndSwap(data[1], data[2]);
    compareAndSwap(data[3], data[4]);
    compareAndSwap(data[5], data[6]);
    // Stage 4 (Even)
    compareAndSwap(data[0], data[1]);
    compareAndSwap(data[2], data[3]);
    compareAndSwap(data[4], data[5]);
    compareAndSwap(data[6], data[7]);
    // Stage 5 (Odd)
    compareAndSwap(data[1], data[2]);
    compareAndSwap(data[3], data[4]);
    compareAndSwap(data[5], data[6]);
    // Stage 6 (Even)
    compareAndSwap(data[0], data[1]);
    compareAndSwap(data[2], data[3]);
    compareAndSwap(data[4], data[5]);
    compareAndSwap(data[6], data[7]);
    // Stage 7 (Odd)
    compareAndSwap(data[1], data[2]);
    compareAndSwap(data[3], data[4]);
    compareAndSwap(data[5], data[6]);
    // Stage 8 (Even)
    compareAndSwap(data[0], data[1]);
    compareAndSwap(data[2], data[3]);
    compareAndSwap(data[4], data[5]);
    compareAndSwap(data[6], data[7]);
}
/*-----------------------------------------------------------------------------------------------*/



/*-----------------------------------------------------------------------------------------------*/
/* For each edge sorts the nodes and creates a 64 bit hash */
/*-----------------------------------------------------------------------------------------------*/
__global__ void Kernel_EdgeHashesSorted(  int numEdges,
										  const uint *d_edge_NodesList,
										  const uint *d_edge_NodesStart, const uint *d_edge_NodesNum,
										  const NodeKeyTuple *d_node_sig,

										  uint64_t* d_edge_neighborHashes, uint numNodes, uint sizeNodeList    )
{
    /* One thread per edge */
    int edge_id = blockIdx.x * blockDim.x + threadIdx.x;

    if (edge_id < numEdges)
    {
		NodeKeyTuple NodeSigs [8]; /* Based on discussion with Paul we can use 8 as an upper bound */

		/*---------------------------------------------------------------------------------------------------*/
		/* A] Load Nodes Signatures */
		int num_NodesE    = d_edge_NodesNum   [edge_id];
		int start_index  = d_edge_NodesStart [edge_id];

		for (int i = 0; i < 8; i++)
		{
			if( i<num_NodesE)
			{
			  uint loc = start_index + i;
			  if(loc > sizeNodeList)
			  {
				  printf(" ErrorEdgeNodeList %d From %d \n", loc,sizeNodeList);
			  }
			  uint nodeInd = d_edge_NodesList[ loc] ;

			  if(nodeInd > numNodes)
			  {
				  printf(" ErrorNodeIndex %d From %d \n", nodeInd,numNodes);
			  }

			  NodeSigs[i] = d_node_sig[ nodeInd ];
			}
			else
			{
				NodeSigs[i] = MAX_TUPLE;
			}
		}

		/* B] Sort Nodes Signatures create a hash for the edge  */
		 sorting_network_8(NodeSigs);

		 if(num_NodesE<8)
		 {
			d_edge_neighborHashes[edge_id] = fnv1a_hash_64( NodeSigs, 8*sizeof(NodeKeyTuple) );
		 }
		 else
		 {
			printf (" Erro Too Many Nodes \n");
		 }
        /*---------------------------------------------------------------------------------------------------*/
    } /* Valid TID */
}
/*-----------------------------------------------------------------------------------------------*/


/*-----------------------------------------------------------------------------------------------*/
/* For each edge sorts the nodes and creates a 64 bit hash for both source and target nodes */
/*-----------------------------------------------------------------------------------------------*/
__global__ void Kernel_EdgeHashesSortedComb(    int numEdges, // Number of threads

												const uint* d_edge_SourceNodes,
												const uint* d_edge_TargetNodes,

												const uint* d_edge_SourcesStart,
												const uint* d_edge_SourcesNum,

												const uint* d_edge_TargetsStart,
												const uint* d_edge_TargetsNum,

												const NodeKeyTuple* d_node_sig,

												uint64_t* d_source_neighbor_hashes,
												uint64_t* d_target_neighbor_hashes    )
{
    // One thread per edge
    int edge_id = blockIdx.x * blockDim.x + threadIdx.x;

    if (edge_id < numEdges)
    {
		NodeKeyTuple NodeSigs[8]; // Max size 8

		/*---------------------------------------------------------------------------------------------------*/
		/* A] Source Nodes Signatures */
		int start_index      = d_edge_SourcesStart [edge_id];
		int num_source_nodes = d_edge_SourcesNum   [edge_id];
		for (int i = 0; i < 8; i++)
		{
			if( i<num_source_nodes)
			{
			  NodeSigs[i] = d_node_sig[ d_edge_SourceNodes[start_index + i] ];
			}
			else
			{
				NodeSigs[i] = MAX_TUPLE;
			}
		}

		/* B] Sort Nodes Signatures create a hash for the edge  */
		sorting_network_8(NodeSigs);
		if(num_source_nodes<8)
		{
			//printf(" %d numSourceNodes %d \n", edge_id, num_source_nodes);
			d_source_neighbor_hashes[edge_id] = fnv1a_hash_64( NodeSigs, 8*sizeof(NodeKeyTuple) );
		}
		else
		{
			printf (" Error Too many source nodes \n");

		}
        /*---------------------------------------------------------------------------------------------------*/

		/*---------------------------------------------------------------------------------------------------*/
		/* B] Target Nodes Signatures */
		int start_indexT     = d_edge_TargetsStart [edge_id];
		int num_target_nodes = d_edge_TargetsNum   [edge_id];

		for (int i = 0; i < 8; i++)
		{
			if( i<num_target_nodes)
			{
				NodeSigs[i] =  d_node_sig[ d_edge_TargetNodes[ start_indexT + i ]];
			}
			else
			{
				NodeSigs[i] = MAX_TUPLE;
			}
		}

		sorting_network_8(NodeSigs);

		if(num_target_nodes<8)
		{
		   //printf(" %d numTargetNodes %d \n", edge_id, num_target_nodes);
		   d_target_neighbor_hashes[edge_id] = fnv1a_hash_64(NodeSigs, 8*sizeof(NodeKeyTuple));
		}
		else
		{
		   printf (" Error Too Many target nodes \n");
		}
		/*---------------------------------------------------------------------------------------------------*/

    } /* Valid TID */
}
/*-----------------------------------------------------------------------------------------------*/


/*-----------------------------------------------------------------------------------------------*/
__global__ void Kernel_InitNodeColor( int numNodes, NodeKeyTuple *d_nodeKey, uint64_t* d_node_colors_output )
{
    int node_id = blockIdx.x*blockDim.x + threadIdx.x;

    if (node_id < numNodes)
    {
        /* Hash the 16-byte tuple to a single 64-bit color */
    	NodeKeyTuple sig = d_nodeKey[node_id];
        d_node_colors_output[node_id] = fnv1a_hash_64(&sig, sizeof(NodeKeyTuple));
    }
}
/*-----------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------*/
__global__ void Kernel_InitEdgeColor( int numEdges, const uint* d_edge_labels, uint64_t* d_edge_colors_output )
{
    int edge_id = blockIdx.x * blockDim.x + threadIdx.x;
    if (edge_id < numEdges)
    {
        d_edge_colors_output[edge_id] = (uint64_t)d_edge_labels[edge_id];
    }
}
/*-----------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------*/
/* Color Iteration for edges */
/*-----------------------------------------------------------------------------------------------*/
__global__ void Kernel_EdgeColors(  int numEdges,
									uint64_t       *d_edge_Colors, // This is updated
									const uint     *d_edge_SourceNodes,
									const uint     *d_edge_SourcesStart,
									const uint     *d_edge_SourcesNum,

									const uint64_t *d_node_Colors,
									const uint     *d_edge_TargetNodes,
									const uint     *d_edge_TargetsStart,
									const uint     *d_edge_TargetsNum,
									int numNodes)
{
    int edge_id = blockIdx.x * blockDim.x + threadIdx.x;

    if (edge_id < numEdges)
    {
		uint64_t NodeNNColors[8]; /* Local Buffer */

		/*---------------------------------------------------------------------------------------------------*/
		/* A] Source Nodes Signatures */
		int start_index      = d_edge_SourcesStart [edge_id];
		int num_source_nodes = d_edge_SourcesNum   [edge_id];
		for (int i = 0; i < 8; i++)
		{
			if( i<num_source_nodes)
			{
				NodeNNColors[i] = d_node_Colors[ d_edge_SourceNodes[start_index + i] ];
			}
			else
			{
				NodeNNColors[i] = UINT64_MAX;
			}
		}
		sorting_network_8(NodeNNColors); // Sort colors
		uint64_t source_hash = fnv1a_hash_64(NodeNNColors, 8*sizeof(uint64_t));
		/*---------------------------------------------------------------------------------------------------*/

		/*---------------------------------------------------------------------------------------------------*/
		/* B] Target Nodes Signatures */
		int start_indexT     = d_edge_TargetsStart [edge_id];
		int num_target_nodes = d_edge_TargetsNum   [edge_id];
		for (int i = 0; i < 8; i++)
		{
			if( i<num_target_nodes)
			{
				NodeNNColors[i] = d_node_Colors[ d_edge_TargetNodes[start_indexT + i] ];
			}
			else
			{
				NodeNNColors[i] = UINT64_MAX;
			}
		}
		sorting_network_8(NodeNNColors); // Sort colors
		uint64_t target_hash = fnv1a_hash_64(NodeNNColors, 8*sizeof(uint64_t));
		/*---------------------------------------------------------------------------------------------------*/

		/* C] Combine and create new color for edge */
		uint64_t combined_hash_data[3] = { d_edge_Colors[edge_id], source_hash, target_hash };
		d_edge_Colors[edge_id] = fnv1a_hash_64(combined_hash_data, 3 * sizeof(uint64_t));
    }
}
/*-----------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------*/
__global__ void Kernel_NodeColors(  int numNodes,
									uint64_t   *d_node_Colors,
									const uint *d_node_edgePrevs,
									const uint *d_node_edgePrevsStart,
									const uint *d_node_edgePrevsNum,

									const uint *d_node_edgeNexts,
									const uint *d_node_edgeNextsStart,
									const uint *d_node_edgeNextsNum,

									const uint64_t *d_edge_Colors,
									int numEdges                         )
{
	int node_id = blockIdx.x * blockDim.x + threadIdx.x;
	if (node_id < numNodes)
	{
		/* A] Node Prevs */
		int num_prev_edges = d_node_edgePrevsNum   [node_id];
		int start_index    = d_node_edgePrevsStart [node_id];

		uint64_t prev_hash = 0;
		for (int i = 0; i < num_prev_edges; i++)
		{
			/* Commutative XOR sum using edge colors */
			prev_hash = prev_hash ^ d_edge_Colors[ d_node_edgePrevs[start_index + i] ];
		}

		/* B] Node Nexts */
		int num_next_edges = d_node_edgeNextsNum   [node_id];
		int start_indexN   = d_node_edgeNextsStart [node_id];

		uint64_t next_hash = 0;
		for (int i = 0; i < num_next_edges; ++i)
		{
		    next_hash = next_hash ^ d_edge_Colors[ d_node_edgeNexts[start_indexN + i] ];
		}

		/* C] Write New Color */
		uint64_t combined_hash_data[3] = { d_node_Colors[node_id], prev_hash, next_hash };

		d_node_Colors[node_id] = fnv1a_hash_64(combined_hash_data, 3 * sizeof(uint64_t));
	}
}
/*-----------------------------------------------------------------------------------------------*/


#endif /* GPU_SOLVER_CUDA_KERNELS_CUH_ */
