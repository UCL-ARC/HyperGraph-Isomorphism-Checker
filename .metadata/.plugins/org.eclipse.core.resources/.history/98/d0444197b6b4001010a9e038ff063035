
#include <iostream>
#include <string>
#include <vector>
#include <fstream>
#include <sstream>
#include "json.hpp"

struct uint2
{
	unsigned int x={}; unsigned int y={};
};

#include "CUDA_Solver/hyperGraph.h" /* CUDA Solver */


using namespace std;




using json = nlohmann::json;
struct IO_hyperEdge
{
	int labelIndex;
	std::vector<uint> sourceNodes;
	std::vector<uint> targetNodes;
};

/*-------------------------------------------------------------------------------------------------------------------*/
/* _Data Input Mimic_ */
/* Graph Details*/
std::vector<std::string>  IO_nodeLabelsDB     [2];
std::vector<uint>         IO_nodeLabelIndex   [2];

vector<uint>              IO_node_EdgeSources [2];
vector<uint>              IO_node_EdgeTargets [2];

std::vector<std::string>  IO_edgeLabelsDB     [2];
std::vector<IO_hyperEdge> IO_edges            [2];
std::vector<uint>         IO_globalInputs     [2];
std::vector<uint>         IO_globalOutputs    [2];
/*-------------------------------------------------------------------------------------------------------------------*/


/*-------------------------------------------------------------------------------------------------------------------*/
/* A] Node Struct compact list that we will copy to GPU */
/*-------------------------------------------------------------------------------------------------------------------*/
uint m_numNodes={}, m_numNodesInput={}, m_numNodesOutput={}; /* Node Counters */
uint m_nodeEdgesPrevsSize = {}, m_nodeEdgesNextsSize = {};   /* Size of the compact arrays */
uint   m_numNodeLabelsDB = {};                               /* Node Type Identifier */

/* Per Node */
uint  *m_node_LabelDBIndex;       /* index of the label that identifies the node  */
uint  *m_node_IOTag;              /* 0 not global input  0: numGInput  > numGInputs is out */

/* Node Edge Connections */
uint2 *m_node_EdgeStartNumPrevs;  /* x start index y  count in node_EdgePrevs array  */
uint2 *m_node_EdgeStartNumNexts;  /* x start index y  count in node_EdgeNexts array  */

/* Each node will write its input and output edges into these compact arrays */
uint  *m_node_EdgePrevs;          /* "From Edge Sources " */
uint  *m_node_EdgeNexts;          /* "From Edge Targets " */
/*-------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------*/
/* B] Edge struct compact list */
/*-------------------------------------------------------------------------------------------------------------------*/

uint m_numEdges={};                                          /* Edge Counter */
uint m_edgeNodesSourceSize = {}, m_edgeNodesTargetSize = {}; /* Size of the compact arrays */
uint m_numEdgeLabelsDB = {};                                 /* Edge Type Identifier */

/* Per Node */
uint  *m_edge_LabelDBIndex;    /* index of the label that identifies the node  */

/* Edge Node Connections */
uint2 *m_edge_NodeStartNumSources;  /* x start index y  count in edge_NodesSources array  */
uint2 *m_edge_NodeStartNumTargets;  /* x start index y  count in edge_NodesTargets array  */

/* Each edge will write its source and target nodes into these compact arrays */
uint *m_edge_NodesSources;
uint *m_edge_NodesTargets;
/*-------------------------------------------------------------------------------------------------------------------*/





/*-------------------------------------------------------------------------------------------------------------------*/
/* IO Mimic by reading a JSON file and creating the compact lists for node and edges */
/*-------------------------------------------------------------------------------------------------------------------*/
void parseGraphJSON_global(std::istream& json_stream,
		                   std::vector<std::string>  &IO_node_LabelsDB, std::vector<uint>         &IO_node_LabelsIndex,

						   std::vector<uint>         &IO_globalInputs,  std::vector<uint>         &IO_globalOutputs,

						   std::vector<std::string>  &IO_edge_LabelsDB, std::vector<IO_hyperEdge> &IO_edges)
{
	json j;

	// Maps for tracking unique labels
	std::map<std::string, int> node_label_to_index;
	std::map<std::string, int> edge_label_to_index;

	// Clear all vectors passed by reference
	IO_node_LabelsDB.clear();
	IO_node_LabelsIndex.clear();
	IO_edge_LabelsDB.clear();
	IO_edges.clear();
	IO_globalInputs.clear();
	IO_globalOutputs.clear();


	try
	{


		json_stream >> j;

		/*-----------------------------------------------------------------------------*/
		/* 1. Read Node and extract unique labels */
		int node_count = 0;
		for (const auto& node_obj : j["nodes"])
		{
			std::string label = node_obj["type_label"];
			int index;
			auto it = node_label_to_index.find(label);

			if (it == node_label_to_index.end())
			{
				IO_node_LabelsDB.push_back(label);
				index = IO_node_LabelsDB.size() - 1;
				node_label_to_index[label] = index;
			}
			else
			{
				index = it->second;
			}
			IO_node_LabelsIndex.push_back(index);
			node_count++;
		}
		/*-----------------------------------------------------------------------------*/



		/*-----------------------------------------------------------------------------*/
		/* 2. Extract Hyperedges */
		for (const auto& edge_obj : j["hyperedges"])
		{
			IO_hyperEdge edge;
			std::string label_str = edge_obj["type_label"];
			int index;
			auto it = edge_label_to_index.find(label_str);

			if (it == edge_label_to_index.end())
			{
				// It's a new edge label
				IO_edge_LabelsDB.push_back(label_str);
				index = IO_edge_LabelsDB.size() - 1;
				edge_label_to_index[label_str] = index;
			}
			else
			{
				// We've seen this label. Get its stored index.
				index = it->second;
			}

			// Store the index, not the string
			edge.labelIndex = index;
			// --- End Edge Label Logic ---

			/* Debug not used on GPU */
			edge.sourceNodes = edge_obj["source_nodes"].get<std::vector<uint>>();
			edge.targetNodes = edge_obj["target_nodes"].get<std::vector<uint>>();
			IO_edges.push_back(edge);
		}
		/*-----------------------------------------------------------------------------*/


		/*-----------------------------------------------------------------------------*/
		/* 3. Extract Global Inputs Nodes */
		IO_globalInputs = j["Inputs"].get<std::vector<uint>>();
		/*-----------------------------------------------------------------------------*/

		/*-----------------------------------------------------------------------------*/
		/* 4. Extract Global Output Nodes */
		IO_globalOutputs = j["Outputs"].get<std::vector<uint>>();
		/*-----------------------------------------------------------------------------*/

	}
	catch (json::parse_error& e)
	{
		std::cerr << "JSON parse error: " << e.what() << std::endl;
	}
	catch (json::type_error& e)
	{
		std::cerr << "JSON type error: " << e.what() << std::endl;
	}
	catch (std::exception& e)
	{
		std::cerr << "An unexpected error occurred: " << e.what() << std::endl;
	}
}
/*-------------------------------------------------------------------------------------------------------------------*/

void printGraphStats(   // Node Info
						unsigned int numNodes,
						unsigned int numNodesInput, // Assuming you still want to pass these summary counts
						unsigned int numNodesOutput,
						const uint*  node_LabelDBIndex,	unsigned int numNodeLabelsDB,
						const uint2* node_EdgeStartNumPrevs,
						const uint2* node_EdgeStartNumNexts,
						const uint*  node_IOTag,

						// Edge Info
						unsigned int numEdges,
						const uint* edge_LabelDBIndex, unsigned int numEdgeLabelsDB,
						const uint2* edge_NodeStartNumSources,
						const uint2* edge_NodeStartNumTargets
					  )
{


    std::cout << "## ðŸ“Š Graph Overall Statistics ##" << std::endl;
    std::cout << std::left << std::setw(25) << "* Total Nodes:" << numNodes << std::endl;
    std::cout << std::left << std::setw(25) << "* Total Edges:" << numEdges << std::endl;
    std::cout << std::left << std::setw(25) << "* Unique Node Labels:" << numNodeLabelsDB << std::endl;
    std::cout << std::left << std::setw(25) << "* Unique Edge Labels:" << numEdgeLabelsDB << std::endl;
    std::cout << std::left << std::setw(25) << "* Global Input Nodes:" << numNodesInput << std::endl;
    std::cout << std::left << std::setw(25) << "* Global Output Nodes:" << numNodesOutput << std::endl;
    std::cout << "---" << std::endl;


    std::cout << "## ðŸ”— Edge Degree Distribution ##" << std::endl;
    std::map<unsigned int, unsigned int> edgeSourceCounts;
    std::map<unsigned int, unsigned int> edgeTargetCounts;
    std::map<unsigned int, unsigned int> edgeTotalCounts;


    for (unsigned int i = 0; i < numEdges; ++i)
    {
        unsigned int numSources = edge_NodeStartNumSources[i].y;
        unsigned int numTargets = edge_NodeStartNumTargets[i].y;
        unsigned int totalNodes = numSources + numTargets;

        edgeSourceCounts[numSources]++;
        edgeTargetCounts[numTargets]++;
        edgeTotalCounts[totalNodes]++;
    }

    std::cout << "### By Number of Source Nodes (Inputs):" << std::endl;
    for (const auto& pair : edgeSourceCounts)
    {
        std::cout << "* " << std::setw(3) << pair.first << " sources: " << pair.second << " edges" << std::endl;
    }
    std::cout << std::endl;

    std::cout << "### By Number of Target Nodes (Outputs):" << std::endl;
    for (const auto& pair : edgeTargetCounts)
    {
        std::cout << "* " << std::setw(3) << pair.first << " targets: " << pair.second << " edges" << std::endl;
    }
    std::cout << std::endl;

    std::cout << "### By Total Nodes (Sources + Targets):" << std::endl;
    for (const auto& pair : edgeTotalCounts)
    {
        std::cout << "* " << std::setw(3) << pair.first << " total nodes: " << pair.second << " edges" << std::endl;
    }
    std::cout << "---" << std::endl;


    std::cout << "## â†”ï¸ Node Degree Distribution ##" << std::endl;
    std::map<unsigned int, unsigned int> nodePrevCounts;
    std::map<unsigned int, unsigned int> nodeNextCounts;
    std::map<unsigned int, unsigned int> nodeTotalCounts;
    std::map<unsigned int, unsigned int> nodeIOCounts;


    for (unsigned int i = 0; i < numNodes; ++i)
    {
        unsigned int numPrevs   = node_EdgeStartNumPrevs[i].y;
        unsigned int numNexts   = node_EdgeStartNumNexts[i].y;
        unsigned int totalEdges = numPrevs + numNexts;
        unsigned int nodeIO     = node_IOTag[i];


        nodePrevCounts[numPrevs]++;
        nodeNextCounts[numNexts]++;
        nodeTotalCounts[totalEdges]++;
        nodeIOCounts[nodeIO]++;
    }

    std::cout << "### By Number of Incoming Edges (Prevs):" << std::endl;
    for (const auto& pair : nodePrevCounts)
    {
        std::cout << "* " << std::setw(3) << pair.first << " incoming edges: " << pair.second << " nodes" << std::endl;
    }
    std::cout << std::endl;

    std::cout << "### By Number of Outgoing Edges (Nexts):" << std::endl;
    for (const auto& pair : nodeNextCounts) {
        std::cout << "* " << std::setw(3) << pair.first << " outgoing edges: " << pair.second << " nodes" << std::endl;
    }
    std::cout << std::endl;

    std::cout << "### By Total Edge Connections (Prevs + Nexts):" << std::endl;
    for (const auto& pair : nodeTotalCounts)
    {
        std::cout << "* " << std::setw(3) << pair.first << " total edges: " << pair.second << " nodes" << std::endl;
    }
    std::cout << "---" << std::endl;

    std::cout << "### NodeIO:" << std::endl;
    for (const auto& pair : nodeIOCounts)
    {
        std::cout << "* " << std::setw(3) << pair.first << " IO: " << pair.second << " nodes" << std::endl;
    }
    std::cout << "---" << std::endl;
}

int main()
{

	/*-------------------------------------------------------------------------------------------*/
	                                   /* _Mimic Input_ */

	string filenames[2];
	filenames[0] = "../../Input/DrugALarge.json";
	filenames[1] = "../../Input/DrugBLarge.json";

    for (int gInd = 0;gInd<1;gInd++ )
	{
		std::ifstream file_stream(filenames[gInd]);
		if (!file_stream.is_open())
		{
			std::cerr << "Error: Could not open file " << filenames[gInd] << std::endl;
			return false;
		}
		parseGraphJSON_global(file_stream, IO_nodeLabelsDB[gInd], IO_nodeLabelIndex[gInd],
										   IO_globalInputs[gInd], IO_globalOutputs[gInd],
										   IO_edgeLabelsDB[gInd], IO_edges[gInd]);
		file_stream.close();

		cout<<" IONodeLabels "<<IO_nodeLabelsDB[gInd].size()<<" IONodes "<<IO_nodeLabelIndex[gInd].size()
			<<" IOInputNodes "<<IO_globalInputs[gInd].size()<<" IOOutputNodes "<<IO_globalOutputs[gInd].size()
			<<" IOEdgeLabels "<<IO_edgeLabelsDB[gInd].size()<<" IOEdges "<<IO_edges[gInd].size()<<endl;

		/*-------------------------------------------------------------------------------------------*/



		/*-------------------------------------------------------------------------------------------*/
							/* Edge Sorting by total, input and output counts */
		std::sort(  IO_edges[gInd].begin(), IO_edges[gInd].end(), [](const IO_hyperEdge& a, const IO_hyperEdge& b)
				 {
					// Primary key: Total number of nodes
					int total_a = a.sourceNodes.size() + a.targetNodes.size();
					int total_b = b.sourceNodes.size() + b.targetNodes.size();

					if (total_a != total_b)
					{
						return total_a < total_b; // Sort by total size (ascending)
					}
					// Secondary key: Number of inputs
					int inputs_a = a.sourceNodes.size();
					int inputs_b = b.sourceNodes.size();

					if (inputs_a != inputs_b)
					{
						return inputs_a < inputs_b; // 2. Sort by input size (ascending)
					}
					// Tertiary key: Number of outputs
					return a.targetNodes.size() < b.targetNodes.size(); // 3. Sort by output size (ascending)
				 }
		);
										  /* End Edge Sorting */
		/*-------------------------------------------------------------------------------------------*/


		/*===========================================================================================*/
					   /* Create compact arrays and pass to the GPU */
		/*===========================================================================================*/

		/* Set Global Vars to IO Value for edges */
		m_numEdges        = IO_edges[gInd].size();
		m_numEdgeLabelsDB = IO_edgeLabelsDB[gInd].size();

		/* Set Global Vars to IO Value for nodes */
		m_numNodes        = IO_nodeLabelIndex[gInd].size();
		m_numNodesInput   = IO_globalInputs[gInd].size();
		m_numNodesOutput  = IO_globalOutputs[gInd].size();
		m_numNodeLabelsDB = IO_nodeLabelsDB[gInd].size();


		/*-------------------------------------------------------------------------------------------*/
		/* ** This can be done when reading/creating the graph input saving this iteration */

		/* A0] Create Compact List for nodes to store the edges it connects by incrementing each nodes counter  */
		m_node_EdgeStartNumPrevs = new uint2 [m_numNodes](); /* Arr1 */
		m_node_EdgeStartNumNexts = new uint2 [m_numNodes](); /* Arr2 */
		for (int e=0;e<m_numEdges;e++)
		{
			/* Each edge will increment its source nodes as a Next */
			for(int i=0;i<IO_edges[gInd].at(e).sourceNodes.size();i++)
			{
				m_node_EdgeStartNumNexts[IO_edges[gInd].at(e).sourceNodes.at(i)].y++;
				m_edgeNodesSourceSize++;
			}

			/* Each edge will increment its target nodes as a Prev */
			for(int i=0;i<IO_edges[gInd].at(e).targetNodes.size();i++)
			{
				m_node_EdgeStartNumPrevs[IO_edges[gInd].at(e).targetNodes.at(i)].y++;
				m_edgeNodesTargetSize++;
			}
		}
		/*-------------------------------------------------------------------------------------------*/


		/*-------------------------------------------------------------------------------------------*/
		/* A1] Loop over all nodes and complete the locations of where each needs to read its "next" and "prev" from using a running sum */

		m_node_LabelDBIndex = new uint [m_numNodes](); /* Arr3 */
		for (int n=0;n<m_numNodes;n++)
		{
			m_node_LabelDBIndex[n] = IO_nodeLabelIndex[gInd].at(n);

			/* Prev Array*/
			m_node_EdgeStartNumPrevs[n].x = m_nodeEdgesPrevsSize;
			m_nodeEdgesPrevsSize += m_node_EdgeStartNumPrevs[n].y;

			/* Next Array*/
			m_node_EdgeStartNumNexts[n].x = m_nodeEdgesNextsSize;
			m_nodeEdgesNextsSize += m_node_EdgeStartNumNexts[n].y;
		}
		m_node_EdgePrevs        = new uint   [m_nodeEdgesPrevsSize]; /* Arr4 */
		m_node_EdgeNexts        = new uint   [m_nodeEdgesNextsSize]; /* Arr5 */
		/*------------------------------------------------------------------------*/

		/*------------------------------------------------------------------------*/
		/* A2 IO Tag */
		int isError = -1;
		m_node_IOTag        = new uint [m_numNodes](); /* Arr6 */

		for (int n=0;n<m_numNodesInput;n++)
		{
			m_node_IOTag[IO_globalInputs[gInd].at(n)] = 1;
		}

		for (int n=0;n<m_numNodesOutput;n++)
	    {
		  if(m_node_IOTag[IO_globalOutputs[gInd].at(n)]==0)
		  {
		    m_node_IOTag[IO_globalOutputs[gInd].at(n)] = 2;
		  }
		  else if(m_node_IOTag[IO_globalOutputs[gInd].at(n)]==1)
		  {
			  m_node_IOTag[IO_globalOutputs[gInd].at(n)]=3;
		  }
		  else
		  {
			  m_node_IOTag[IO_globalOutputs[gInd].at(n)]++;
		  }
		}
		/*------------------------------------------------------------------------*/


		cout<<" EdgeSourceCSR "<<m_edgeNodesSourceSize<<" EdgeTargetCSR "<<m_edgeNodesTargetSize
			<<" NodeSourceCSR "<<m_nodeEdgesPrevsSize<<" NodeTargetCSR "<<m_nodeEdgesNextsSize<<endl;

		/* Used for the node running sum to store elements and also a debug counter vs A1] values*/
		uint *DEBUGnode_CountSources   = new uint   [m_numNodes](); /* Arr7 */
		uint *DEBUGnode_CountTargets   = new uint   [m_numNodes](); /* Arr8 */


		/*-------------------------------------------------------------------------------------------*/
				  /* B] Populate compact list for edges and nodes by looping over edges   */
		m_edge_NodeStartNumSources = new uint2 [m_numEdges];               /* Arr9 */
		m_edge_NodeStartNumTargets = new uint2 [m_numEdges];               /* Arr10 */
		m_edge_NodesSources        = new uint  [m_edgeNodesSourceSize];    /* Arr11 */
		m_edge_NodesTargets        = new uint  [m_edgeNodesTargetSize];    /* Arr12 */


		int DEBUGedgeCounterSources ={}, DEBUGedgeCounterTargets={}; /* Local Counter but also used as DEBUG to check counters match */

		/* B1] Loop over sorted edges */
		for (int e=0;e<m_numEdges;e++)
		{
			/*-------------------------------------------------------------------*/
						  /* Start and Num for Edge Source Nodes */
			uint2 pair = {};
			pair.x = DEBUGedgeCounterSources;
			pair.y = IO_edges[gInd].at(e).sourceNodes.size();
			m_edge_NodeStartNumSources[e] = pair;

			/* Loop over source nodes to fill the compact array */
			for(int i=0;i<pair.y;i++)
			{
				/* Write Edge Source Nodes into compact Array */
				uint nID = IO_edges[gInd].at(e).sourceNodes.at(i);
				m_edge_NodesSources[ DEBUGedgeCounterSources ] = nID;
				DEBUGedgeCounterSources++;

				/* A] Fill The Node Next List and Inc Debug */
				m_node_EdgeNexts [ DEBUGnode_CountTargets[ nID ] ]= e;
				DEBUGnode_CountTargets[ nID ]++;
			}
			/*-------------------------------------------------------------------*/

			/*-------------------------------------------------------------------*/
						 /* Start and Num for Edge Target Nodes */
			pair.x = DEBUGedgeCounterTargets;
			pair.y = IO_edges[gInd].at(e).targetNodes.size();
			m_edge_NodeStartNumTargets[ e ]=pair;

			/* Loop over target nodes to fill the compact array */
			for(int i=0;i<pair.y;i++)
			{
				/* Write Edge Target Nodes into compact Array */
				uint nID = IO_edges[gInd].at(e).targetNodes.at(i);
				m_edge_NodesTargets[ DEBUGedgeCounterTargets ] = nID;
				                     DEBUGedgeCounterTargets++;

				/* A] Fill The Node Prev List and Inc Debug */
				m_node_EdgePrevs[ DEBUGnode_CountSources[ nID ] ]= e;
				                  DEBUGnode_CountSources[ nID ]++;
			}
			/*-------------------------------------------------------------------*/
		}

		 /* End B] Populate compact list for edges and nodes by looping over edges   */
		/*-------------------------------------------------------------------------------------------*/





		cout<<" DEBUG: EdgeSourceCountCSR "<<DEBUGedgeCounterSources<<" EdgeTargetCountCSR "<<DEBUGedgeCounterTargets<<endl;


		/* Check Node Mapping was correct */
		for (int n=0;n<m_numNodes;n++)
		{
			if( m_node_EdgeStartNumPrevs[n].y != DEBUGnode_CountSources[n])
			{
				cout<<n<<" Error SourceNodeEdgeMapping Got "<<DEBUGnode_CountSources[n]<<" Expected "<<m_node_EdgeStartNumPrevs[n].y<<endl;
			}

			if( m_node_EdgeStartNumNexts[n].y != DEBUGnode_CountTargets[n])
			{
				cout<<n<<" Error TargetNodeEdgeMapping Got "<<DEBUGnode_CountTargets[n]<<" Expected "<<m_node_EdgeStartNumNexts[n].y<<endl;
			}
		}


		/* Copy to GPU */
	    std::cout << "\n--- Calling printGraphStats ---\n";
	    printGraphStats(
	        // Node Args
	        m_numNodes, m_numNodesInput, m_numNodesOutput,
			m_node_LabelDBIndex, m_numNodeLabelsDB,
	        m_node_EdgeStartNumPrevs,
	        m_node_EdgeStartNumNexts,
			m_node_IOTag,
	        // Edge Args
	        m_numEdges,
			m_edge_LabelDBIndex,m_numEdgeLabelsDB,
	        m_edge_NodeStartNumSources,
	        m_edge_NodeStartNumTargets
	    );
	    std::cout << "--- Finished printGraphStats ---\n";


		/* Temp CounterArrays */
		delete [] DEBUGnode_CountSources;
		delete [] DEBUGnode_CountTargets;

		delete [] m_edge_NodesSources;
		delete [] m_edge_NodesTargets;
		delete [] m_edge_NodeStartNumSources;
		delete [] m_edge_NodeStartNumTargets;

		delete [] m_node_LabelDBIndex;
		delete [] m_node_IOTag;

		delete [] m_node_EdgePrevs;
		delete [] m_node_EdgeNexts;
		delete [] m_node_EdgeStartNumPrevs;
		delete [] m_node_EdgeStartNumNexts;

    }

	return 0;
}
