# Open Hypergraph Colouring

The general open hypergraph isomorphism uses an iterative graph colouring approach.
This approach can be applied to acquire a canonical form for each graph separately, or a pair of graphs can be analysed together in tandem in order to provide opportunities for early return.

The algorithm can be broken down into three major steps:

- An initial colouring of both nodes and edges (wires and boxes) based on information that is present in each individually e.g. type/label, global input/output.
- Iterative colour refinement: colours of nodes are updated based on the colours of all the edges that they are connected to directly; edges are then updated based on the colours of all the nodes to which they are connected directly. This process repeats until the graph colouring is stable.
- Symmetry breaking: groups of nodes or edges which have the same colour at this stage point to a symmetry (an automorphism group). In order for each node/edge to have a unique colour, we break the symmetry and then propagate the colour information that this creates using the iterative colour refinement.

The algorithm stops once every node and edge is uniquely coloured.

We'll use the following terminology:

- _colour_: A colour is just a integer label on a node/edge which is derived from the structural information in the graph. A value of -1 is _uncoloured_.
- _colouring_: A map from node/edge indices to colours. The colouring is initialised to _uncoloured_.
- _colour key_: The colour key is constructed for a node/edge by concatenation of the colours of its neighbours.
- _colour set_: A colour set is the subset of nodes/edges in the graph that has a specific colour. The algorithm proceeds until all colour sets are singletons.

The algorithm will store two separate colourings for nodes and edges.

## The Initial Colouring

The initial node colouring has two stages.

- Global Interface Colouring: nodes on the global interface are uniquely identified and therefore can be immediately uniquely coloured. The first step in colouring is therefore to iterate over the global interface list (defined as the concatenation of the global inputs followed by global outputs). A new colour (starting at 0 and incrementing each time) is given to each node in this list that is not already coloured (since a node may appear in this concatenated list more than once).
- Label colouring: a histogram is formed on the remaining nodes based on their labels (types), so that we have a map from a label $l$ to the number of remaining nodes with that label $n_l$. A new colour is applied to all the uncoloured nodes of each type so that $c_{l_{i+1}}$ = $c_{l_{i}} + n_{l_i}$ (where the sequence $[l_0, l_1, ...]$ is sorted). This is so that during the colour refinement of each colour set, fresh colours can be generated without conflicting with any colours generated by refining another colour set in parallel.

The initial edge colouring has only one stage since edges are not part of the global interface, and is the same as the label colouring for nodes.

After this stage there will be no uncoloured nodes or edges left.

## Colour Refinement

For each non-singleton colour set, we now want to try to update the colouring based on the neighbours of the nodes/edges in that colour set.



## Symmetry Breaking
