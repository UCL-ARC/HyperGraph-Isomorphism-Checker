# Open Hypergraph Colouring

The general open hypergraph isomorphism uses an iterative graph colouring approach.
This approach can be applied to acquire a canonical form for each graph separately, or a pair of graphs can be analysed together in tandem in order to provide opportunities for early return.

The algorithm can be broken down into three major steps:

- An initial colouring of both nodes and edges (wires and boxes) based on information that is present in each individually e.g. type/label, global input/output.
- Iterative colour refinement: colours of nodes are updated based on the colours of all the edges that they are connected to directly; edges are then updated based on the colours of all the nodes to which they are connected directly. This process repeats until the graph colouring is stable.
- Symmetry breaking: groups of nodes or edges which have the same colour at this stage point to a symmetry (an automorphism group). In order for each node/edge to have a unique colour, we break the symmetry and then propagate the colour information that this creates using the iterative colour refinement.

The algorithm stops once every node and edge is uniquely coloured.

We'll use the following terminology:

- _colour_: A colour is just a integer label on a node/edge which is derived from the structural information in the graph. A value of -1 is _uncoloured_.
- _colouring_: A map from node/edge indices to colours. The colouring is initialised to _uncoloured_.
- _colour key_: The colour key is constructed for a node/edge by concatenation of the colours of its neighbours.
- _colour set_: A colour set is the subset of nodes/edges in the graph that has a specific colour. The algorithm proceeds until all colour sets are singletons.

The algorithm will store two separate colourings for nodes and edges.

## The Initial Colouring

The initial node colouring has two stages.

- Global Interface Colouring: nodes on the global interface are uniquely identified and therefore can be immediately uniquely coloured. The first step in colouring is therefore to iterate over the global interface list (defined as the concatenation of the global inputs followed by global outputs). A new colour (starting at 0 and incrementing each time) is given to each node in this list that is not already coloured (since a node may appear in this concatenated list more than once).
- Label colouring: a histogram is formed on the remaining nodes based on their labels (types), so that we have a map from a label $l$ to the number of remaining nodes with that label $n_l$. A new colour is applied to all the uncoloured nodes of each type so that $c_{l_{i+1}}$ = $c_{l_{i}} + n_{l_i}$ (where the sequence $[l_0, l_1, ...]$ is sorted). This is so that during the colour refinement of each colour set, fresh colours can be generated without conflicting with any colours generated by refining another colour set in parallel.

The initial edge colouring has only one stage since edges are not part of the global interface, and is the same as the label colouring for nodes.

After this stage there will be no uncoloured nodes or edges left.

## Colour Refinement

For each non-singleton colour set, we now want to try to update the colouring based on the neighbours of the nodes/edges in that colour set. We do this by inspecting the colours of its neighbours in order to construct a colour key, and then split the colour set into new colour sets based on their colour key.

### Node colour key construction

Nodes attach to edges, so it is the colours of neighbouring edges which will make up the colour key. The colour key has two parts: the first for incoming edges and the second part for outgoing edges. Each part is the concatenation of all of the edge colours **sorted**. The colours must be sorted because the node to edge relationship is unordered.

### Edge colour key

Edges attach to nodes, so it is the colours of neighbourin gnodes which will make up the colour key. The colour key is constructed the same was as the node colour key, except that the list is **not sorted**, since the order of inputs and outputs has semantic consequences in edges.

### Colour set refinement

A new colour is then assigned to each subset, in the same way as for the initial colouring i.e. leaving enough space between each colour so that there are enough colours reserved for each non-singleton colour to continue the refinement process.

The process alternates between refining node colourings and edge colourings until both the node colouring and edge colouring is stable (no further changes are able to be made).
It is important that the node colour refinement step completes before starting the edge refinement step (and vice versa) so that the refinement has complete information and the process is fully deterministic.

## Symmetry Breaking

If the algorithm arrives at a stable colouring where nodes/edges are not uniquely coloured, then remaining non-singleton colour-sets result from some underlying symmetry giving rise to an automorphism group. However, the nature of that symmetry is not immediately apparent from the colouring (for example, a ring and a clique would both result in nodes which all have the same colour, but these graphs are very different in structure).

To proceed with a colour we may arbitrarily choose one element in the colour set to recolour with a new colour. The consequences of this are then propagated using the usual iterative colour refinement until the colouring again stabilised. For example, in a ring the symmetry breaking would propagate around the entire ring and every node would end up with a unique colour, but in a clique the remaining nodes would still all be equivalent so the colouring would immediately stabilise.

The symmetry breaking process (followed by iterative colour refinement) can be repeated until all colour sets are singletons. In this case the colouring (map from nodes/edges to colours) is only unique up to automorphism.
